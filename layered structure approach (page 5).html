 <html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>layered structure approach</title>
     <link rel="stylesheet" type="text/css" href="/styel 001.css">
    
</head>

<body>

    <header class="header">

        <a href="#" class="logo"><img src="/web images/ananta gyaan logo (2).png"width="50"height="30">ANANTA GYAAN</a>
      <div class="navbar">
        
      <a href="/home 02.html">Home</a>
      <a href="/log in page.html">Login</a>
      <div class="dropdown">
        <button class="dropbtn">Subject 
          <i class="fa fa-caret-down"></i>
        </button>
        <div class="dropdown-content">
          <a href="/web COMPUTER NETWORK/Introduction and Definition of computer network(page 1).html">COMPUTER NETWORK</a> 
        </div>
      </div> 
    </div>
        </nav>
                  
        </p></header>
    
        <div id="container">
    
            <main id="center" class="column">
                <article>
    <h1><u>Layered structure approach </u></h1>
    <p>यह Layered Structure Approach , operating
        system को differant layers मे divided करके , उसे
        develop करने का एक method है और each layer नीचे वाले layer के top पर बनाए जाते है । सबसे
        नीचे की layer hardware की होती है । जब क सबसे ऊपर की layer user interface की होती है ।
    </p>
    <p>Layered Structure Approach के तहत बहुत पहले, THE नामक operating system को E.W.Dijkistra तथा
        उनके student द्वारा सन ् 1968 ई . मे manufactured कया गया था । THE operating system एक
        Batch Operating System था , िजसमे 6 level ( layers ) थे।</p>
    <p>यह THE operating system मे Layer 0 हाड,वेयर को deal करता था । और<br>
        Layer 1 , CPU Scheduling
        अथा,त ् jobs को process के लिए एलोकेट करता था । और<br>
        Layer 2 , मेमोर manage का कार्य, करता था ।<br>
        Layer 3 , ऑपरेटर के console के लिए device driver को contain करता था और जब ki<br>
        Layer 4 , इनपुटर / आउटपुट Devices के लिए Buffering कया करते थे ।</p>
    <p>ये सभी layers को इस तरह design किए गए है कि each layer केवल अपने नीचे वाला layer के
        operation और services का ही use कर सकता है और each layer अपने से higher levels से operations
        के impImentation को hide है किसी सतह के higher layer को यह जानने की need नहींं होती है कि
        किस तरह operations को implement किया जाता है बिRक उसे केवल यह जानने की need होती है कि
        operations 7या करते है । यहाँ each सतह के अलग - अलग कार्य, है और किसी भी सतह को बिना किसी
        भी सतह से सम्बन्धित रखते हुए debug किया जा सकता है । यह Layered Approach का main लाभ यह
        है कि यह operating system के design को modularity प्रदान करता है िजस के कारण operating system को
        आसानी से design और verify किया जा सकता है । Layered Appcoach के साथ सबसे बड़ी परेशानी यह
        है कि इसमे नए level को define करना कठिन होता है अथा,त ् इसमे एक स्तर को दसूरे स्तर से अलग करने
        मे काफी सावधानी की need होती है क्योंकि कोई भी layer अपने नीचे वाले layer services का use
        करता है ।<br>
        <strong> उदाहरण:- </strong> Memory के Device Drivers Memory management routines के नीचे वाले
        layer मे भी define होने चाहिए क्योंकि मेमोर manage मे secoundry memory का use किया जाता रहता है ।
    </p>
    <center><img src="/web images/layered-structure-of-operating-system 01.png"
            alt="layered-structure-of-operating-system" width="500" height="300" align="center" border="2"><br><br>
    </center>
    <h1><u>Architecture of Layered Structure </u></h1>
    <p>This type of operating system was created as an improvement over the early monolithic systems. The operating
        system is split into various layers in the layered operating system, and each of the layers has different
        functionalities. There are some rules in the implementation of the layers as follows.</p>
    <ul>
        <li>A particular layer can access all the layers present below it, but it cannot access them. That is, layer n-1
            can access all the layers from n-2 to 0, but it cannot access the nth</li>
        <li>Layer 0 deals with allocating the processes, switching between processes when interruptions occur or the
            timer expires. It also deals with the basic multiprogramming of the CPU.</li>
    </ul>
    <p>Thus if the user layer wants to interact with the hardware layer, the response will be traveled through all the
        layers from n-1 to 1. Each layer must be designed and implemented such that it will need only the services
        provided by the layers below it.

        <br> There are six layers in the layered operating system. A diagram demonstrating these layers is as
        follows:<br><br>
        <center><img src="/web images/layered-structure-of-operating-system 02.png"
                alt="layered-structure-of-operating-system" width="500" height="400" align="center" border="2"><br><br>
        </center>
    </p>
    <ol type="1">
        <li><strong>Hardware:</strong> This layer interacts with the system hardware and coordinates with all the
            peripheral devices used, such as a printer, mouse, keyboard, scanner, etc. These types of hardware devices
            are managed in the hardware layer.<br>
            The hardware layer is the lowest and most authoritative layer in the layered operating system architecture.
            It is attached directly to the core of the system.</li>
        <li><strong>CPU Scheduling:</strong> This layer deals with scheduling the processes for the CPU. Many scheduling
            queues are used to handle processes. When the processes enter the system, they are put into the job
            queue.<br>
            The processes that are ready to execute in the main memory are kept in the ready queue. This layer is
            responsible for managing how many processes will be allocated to the CPU and how many will stay out of the
            CPU.</li>
        <li><strong>Memory Management:</strong> Memory management deals with memory and moving processes from disk to
            primary memory for execution and back again. This is handled by the third layer of the operating system. All
            memory management is associated with this layer. There are various types of memories in the computer like
            RAM, ROM.<br>
            If you consider RAM, then it is concerned with swapping in and swapping out of memory. When our computer
            runs, some processes move to the main memory (RAM) for execution, and when programs, such as calculator,
            exit, it is removed from the main memory.</li>
        <li><strong>Process Management:</strong> This layer is responsible for managing the processes, i.e., assigning
            the processor to a process and deciding how many processes will stay in the waiting schedule. The priority
            of the processes is also managed in this layer. The different algorithms used for process scheduling are
            FCFS (first come, first served), SJF (shortest job first), priority scheduling, round-robin scheduling, etc.
        </li>
        <li><strong>I/O Buffer:</strong> I/O devices are very important in computer systems. They provide users with the
            means of interacting with the system. This layer handles the buffers for the I/O devices and makes sure that
            they work correctly.<br>
            Suppose you are typing from the keyboard. There is a keyboard buffer attached with the keyboard, which
            stores data for a temporary time. Similarly, all input/output devices have some buffer attached to them.
            This is because the input/output devices have slow processing or storing speed. The computer uses buffers to
            maintain the good timing speed of the processor and input/output devices.</li>
        <li><strong>User Programs:</strong> This is the highest layer in the layered operating system. This layer deals
            with the many user programs and applications that run in an operating system, such as word processors,
            games, browsers, etc. You can also call this an application layer because it is concerned with application
            programs.</li>
    </ol>
    <h3>Advantages of Layered Structure</h3>
    <p>There are several advantages of the layered structure of operating system design, such as:</p>
    <ol type="1">
        <li><strong>Modularity:</strong> This design promotes modularity as each layer performs only the tasks it is
            scheduled to perform.</li>
        <li><strong>Easy debugging:</strong> As the layers are discrete so it is very easy to debug. Suppose an error
            occurs in the CPU scheduling layer. The developer can only search that particular layer to debug, unlike the
            Monolithic system where all the services are present.</li>
        <li><strong>Easy update:</strong> A modification made in a particular layer will not affect the other layers.
        </li>
        <li><strong>No direct access to hardware:</strong> The hardware layer is the innermost layer present in the
            design. So a user can use the services of hardware but cannot directly modify or access it, unlike the
            Simple system in which the user had direct access to the hardware.</li>
        <li><strong>Abstraction:</strong> Every layer is concerned with its functions. So the functions and
            implementations of the other layers are abstract to it.</li>
    </ol>
    <h3>Disadvantages of Layered Structure</h3>
    <p>Though this system has several advantages over the Monolithic and Simple design, there are also some
        disadvantages, such as:</p>
    <ol type="1">
        <li><strong>Complex and careful implementation:</strong> As a layer can access the services of the layers below
            it, so the arrangement of the layers must be done carefully. For example, the backing storage layer uses the
            services of the memory management layer. So it must be kept below the memory management layer. Thus with
            great modularity comes complex implementation.</li>
        <li><strong>Slower in execution:</strong> If a layer wants to interact with another layer, it requests to travel
            through all the layers present between the two interacting layers. Thus it increases response time, unlike
            the Monolithic system, which is faster than this. Thus an increase in the number of layers may lead to a
            very inefficient design.</li>
        <li><strong>Functionality:</strong> It is not always possible to divide the functionalities. Many times, they
            are interrelated and can't be separated.</li>
        <li><strong>Communication:</strong> No communication between non-adjacent layers.</li>
    </ol>

</article>                              
</main>

<nav id="left" class="column">
    <h3>Topics</h3>
    <ul>
        <li><a href="/Disk Scheduling Algorithm (page 13).html">Disk Scheduling Algorithm </a></li>
        <li><a href="/Transfer time and Bandwidh(page 12).html">Transfer time and Bandwidh</a></li>
        <li><a href="/Deadlock detection (page 9).html">Deadlock detection</a></li>
        <li><a href="/what is Hard disk (page 10).html">what is Hard disk</a></li>
        <li><a href="/rotational delay (page 11).html">rotational delay</a></li>
        <li><a href="/Banker's Algorithm (page 8).html">Banker's Algorithm</a></li>
        <li><a href="/Deadlock prevention (page 7).html">Deadlock prevention</a></li>
        <li><a href="/layered structure approach (page 5).html">layered structure approach</a></li>
        <li><a href="/what is kernel (page 3).html">what is kernel</a></li>
        <li><a href="/Deadlock (page 6).html">Deadlock</a></li>
        <li><a href="/types of kernel (page 4).html">types of kernel</a></li>
        <li><a href="/types of operating system (page 2).html">types of operating system</a></li>
        
        <li><a href="/types of operating system (page 2).html">Real time operating system</a></li>
        <li><a href="/types of operating system (page 2).html">Batch operating system</a></li>
        <li><a href="/types of operating system (page 2).html">Distributed operating system</a></li>
        <li><a href="/types of operating system (page 2).html">Network opertaing system</a></li>
        <li><a href="/types of operating system (page 2).html">Single tasking & multi tasking operating system</a></li>
        <li><a href="/types of operating system (page 2).html">Multiprocessing operating system</a></li>
        <li><a href="/types of operating system (page 2).html">multi-programming operating system</a></li>
        <li><a href="/what is o.s (page 1).html">what is operating system</a></li>

        
        <li><a href=""></a></li>
    </ul>

</nav>

<div id="right" class="column">
    <h3>Ads</h3>
    
</div>

</div>

<div id="footer-wrapper">
<footer id="footer"><p>Footer...</p></footer>
</div>

</body>

</html>
</body>
</html>